# -*- coding: utf-8 -*-
"""
	project............: meat-a
	description........: web application for sharing meta information
	date...............: 04/2013
	copyright..........: Sebastian Fedrau

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
	OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
"""

##
#  @file app.py
#  Domain layer.

## @package app
#  Domain layer.

import factory, exception, util, config, tempfile, os
from validators import *
from base64 import b64encode
from database import StreamDb

## The meat-a application layer.
class Application:
	## Requests a new user account. Username and email have to be unique. On success a
	#  mail is generated and stored in the mail queue.
	#  @param username name of the user to create
	#  @param email email address of the user
	#  @return an auto-generated request id and code to activate the account
	def request_account(self, username, email):
		# validate parameters:
		if not validate_username(username):
			raise exception.InvalidParameterException("username")

		if not validate_email(email):
			raise exception.InvalidParameterException("email")

		# store request in database:
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# test if user account or email already exist:
				if db.username_or_email_assigned(scope, username, email):
					raise exception.UsernameOrEmailAlreadyExistException()

				# generate request id & code:
				id = b64encode(util.generate_junk(config.REQUEST_ID_LENGTH))

				while db.user_request_id_exists(scope, id):
					id = b64encode(util.generate_junk(config.REQUEST_ID_LENGTH))

				code = b64encode(util.generate_junk(config.REQUEST_CODE_LENGTH))

				# save user request:
				db.create_user_request(scope, id, code, username, email)

				# TODO generate mail

				scope.complete()

				return id, code

	## Activates a user account. Generates a mail on success.
	#  @param id a request id generated by the Application::request_account() method
	#  @param code a related request code
	#  @return username, email & password (plaintext) of the activated account
	def activate_user(self, id, code):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# find request id & test code:
				request = db.get_user_request(scope, id)

				if request is None:
					raise exception.InvalidRequestIdException()

				if request["request_code"] != code:
					raise exception.InvalidRequestCodeException()

				# activate user account:
				password = util.generate_junk(config.DEFAULT_PASSWORD_LENGTH)
				salt = util.generate_junk(config.PASSWORD_SALT_LENGTH)

				db.activate_user(scope, id, code, util.password_hash(password, salt), salt)

				# TODO generate mail

				scope.complete()

				return request["username"], request["email"], password

	## Disables a user account. Generates a mail on success.
	#  @param username name of the account to disable
	#  @param disabled True to disable the account
	def disable_user(self, username, disabled=True):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				self.__test_user_exists__(scope, db, username)

				db.block_user(scope, username, disabled)

				# TODO generate mail

				scope.complete()

	## Deletes a user account. Generates a mail on success.
	#  @param username name of the account to delete
	#  @param deleted True to delete the account
	def delete_user(self, username, deleted=True):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				self.__test_user_exists__(scope, db, username)

				db.delete_user(scope, username, deleted)

				# TODO generate mail

				scope.complete()

	## Changes the password of a user account. Generates a mail on success.
	#  @param username name of a user account
	#  @param old_password old password (plaintext) of the specified account
	#  @param new_password1 a new password (plaintext) to set
	#  @param new_password2 repeated new password (plaintext)
	def change_password(self, username, old_password, new_password1, new_password2):
		# validate passwords:
		if not validate_password(new_password1):
			raise exception.InvalidParameterException("new_password")

		if new_password1 != new_password2:
			raise exception.PasswordsNotEqualException()

		# change password:
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				self.__test_active_user__(scope, db, username)

				if self.__validate_password__(scope, db, username, old_password):
					salt = util.generate_junk(config.PASSWORD_SALT_LENGTH)
					hash = util.password_hash(new_password1, salt)

					db.update_user_password(scope, username, hash, salt)

					scope.complete()
				else:
					raise exception.InvalidPasswordException()

	## Tests if a password is correct.
	#  @param username a user account
	#  @param password password (plaintext) to validate
	#  @return True if the given password is correct
	def validate_password(self, username, password):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				self.__test_active_user__(scope, db, username)

				return self.__validate_password__(scope, db, username, password)

	## Generates a password request and email.
	#  @param username a user account
	#  @param email email address of the specified user account
	#  @return an auto-generated id and code to change the user password
	def request_new_password(self, username, email):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# test if user is active:
				user = db.get_user(scope, username)

				if user["blocked"]:
					raise exception.UserIsBlockedException()

				if user["deleted"]:
					raise exception.UserNotFoundException()

				# test if email address is correct:
				if email.lower() <> user["iemail"]:
					raise exception.InvalidEmailAddressException()

				# delete existing request ids:
				db.remove_password_requests_by_user_id(scope, user["id"])

				# create request id & code:
				id = b64encode(util.generate_junk(config.REQUEST_ID_LENGTH))

				while db.password_request_id_exists(scope, id):
					id = b64encode(util.generate_junk(config.REQUEST_ID_LENGTH))

				code = b64encode(util.generate_junk(config.REQUEST_CODE_LENGTH))

				# save password request:
				db.create_password_request(scope, id, code, user["id"])

				# TODO generate mail

				scope.complete()

				return id, code, user["username"], user["email"]

	## Resets a password using a generated password request id & code. Generates a mail on success.
	#  @param id a password request id
	#  @param code a related request code
	#  @param new_password1 a new password (plaintext)
	#  @param new_password2 repeated new password (plaintext)
	def reset_password(self, id, code, new_password1, new_password2):
		# validate passwords:
		if not validate_password(new_password1):
			raise exception.InvalidParameterException("new_password")

		if new_password1 != new_password2:
			raise exception.PasswordsNotEqualException()

		# resets password:
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# find request id & test code:
				request = db.get_password_request(scope, id)

				if request is None:
					raise exception.InvalidRequestIdException()

				if request["request_code"] != code:
					raise exception.InvalidRequestCodeException()

				if request["user"]["blocked"]:
					raise exception.UserIsBlockedException()

				if request["user"]["deleted"]:
					raise exception.UserNotFoundException()

				# change password:
				salt = util.generate_junk(config.PASSWORD_SALT_LENGTH)

				hash = util.password_hash(new_password1, salt)
				db.reset_password(scope, id, code, hash, salt)

				# TODO generate mail

				scope.complete()

	## Updates the details of a user account.
	#  @param username a user account
	#  @param email email address to set
	#  @param firstname firstname to set
	#  @param lastname lastname to set
	#  @param gender gender to set
	#  @param language language to set
	#  @param protected protected status to set
	def update_user_details(self, username, email, firstname, lastname, gender, language, protected):
		# validate parameters:
		if not validate_email(email):
			raise exception.InvalidParameterException("email")

		if not validate_firstname(firstname):
			raise exception.InvalidParameterException("firstname")

		if not validate_lastname(lastname):
			raise exception.InvalidParameterException("lastname")

		if not validate_gender(gender):
			raise exception.InvalidParameterException("gender")

		if not validate_language(language):
			raise exception.InvalidParameterException("language")

		if protected is None or (protected != True and protected != False):
			raise exception.InvalidParameterException("protected")

		# update user details:
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				self.__test_active_user__(scope, db, username)

				# test email
				if not db.user_can_change_email(scope, username, email):
					raise exception.EmailAlreadyAssignedException()

				# update user details:
				db.update_user_details(scope, username, email, firstname, lastname, gender, language, protected)

				scope.complete()

	## Updates the avatar of a user account.
	#  @param username a user account
	#  @param filename filename of the image
	#  @param stream input stream for reading image data
	def update_avatar(self, username, filename, stream):
		# get file extension:
		ext = os.path.splitext(filename)[1]

		if not ext.lower() in config.AVATAR_EXTENSIONS:
			raise exception.InvalidImageFormatException()

		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# test if user is active:
				self.__test_active_user__(scope, db, username)

				# write temporary file:
				with tempfile.NamedTemporaryFile(mode = "wb", dir = config.TMP_DIR, delete = False) as f:
					map(f.write, util.read_from_stream(stream, max_size = config.AVATAR_MAX_FILESIZE))

				# validate image format:
				try:
					if not validate_image_file(f.name, config.AVATAR_MAX_FILESIZE, config.AVATAR_MAX_WIDTH, config.AVATAR_MAX_HEIGHT, config.AVATAR_FORMATS):
						raise exception.InvalidImageFormatException()

				except exception.Exception, ex:
					os.unlink(f.name)
					raise ex

				# move file to avatar folder:
				try:
					while True:
						filename = "%s%s" % (util.hash("%s-%s-%s-%s" % (util.now(), util.generate_junk(32), username, filename)), ext)
						path = os.path.join(config.AVATAR_DIR, filename)

						if not os.path.exists(path):
							break

					os.rename(f.name, path)

					# update database:
					db.update_avatar(scope, username, filename)

					scope.complete()

				except EnvironmentError, err:
					os.unlink(f.name)
					raise exception.InternalFailureException(str(err))

	## Gets all details of a user account excepting blocked status and password.
	#  @param username a user account
	#  @return a dictionary holding user information ({ "username": str, "firstname": str, "lastname": str, "email": str,
	#          "gender": str, "created_on": datetime, "avatar": str, "protected": bool, "following":  [ str, str, ... ],
	#          "blocked": bool, "language": str })
	def get_full_user_details(self, username):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				details = db.get_user(scope, username)

				if details is None or details["deleted"]:
					raise exception.UserNotFoundException()

				user = {}

				for k in ["username", "firstname", "lastname", "email", "gender", "created_on", "avatar", "protected", "blocked", "language"]:
					user[k] = details[k]

				user["following"] = db.get_followed_usernames(scope, username)

				return user

	## Gets details of a user account depending on protected status and friendship.
	#  @param account user account who wants to receive the user details
	#  @param username user to get details from
	#  @return a dictionary holding user information ({ "username": str, "firstname": str, "lastname": str, "email": str,
	#          "gender": str, "created_on": datetime, "avatar": str, "protected": bool, "following":  [ str, str, ... ] };
	#           only friends can see the "email", "following" and "avatar" fields when the account is protected)
	def get_user_details(self, account, username):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# get details from requester:
				user_a = db.get_user(scope, account)

				if user_a is None or user_a["deleted"]:
					raise exception.UserNotFoundException()

				# get requested details:
				return self.__get_user_details__(scope, db, user_a, username)

	## Finds users by a search query.
	#  @param account user account who searches the data store
	#  @param query a search query
	#  @return an array, each element is a dictionary holding user information ({ "name": str, "firstname": str, "lastname": str,
	#          "email": str, "gender": str, "created_on": datetime, "avatar": str, "protected": bool,
	#          "following":  [ str, str, ... ] }; only friends can see the "email", "following" and "avatar" fields)
	def find_user(self, account, query):
		with self.__create_db_connection__() as conn:
			with conn.enter_scope() as scope:
				db = self.__create_user_db__()

				# get details from requester:
				requester = db.get_user(scope, account)

				if requester is None or requester["deleted"]:
					raise exception.UserNotFoundException()

				# search users:
				result = []

				for username in db.search(scope, query):
					if username <> requester["username"]:
						result.append(self.__get_user_details__(scope, db, requester, username))

				return result

	# gets user information depending on friendship:
	def __get_user_details__(self, scope, db, requester, username):
		# get requested details:
		user = db.get_user(scope, username)

		if user is None or user["deleted"]:
			raise exception.UserNotFoundException()

		friend = False

		if (requester["username"] == user["username"]) or (user["protected"] and requester["username"] in user["following"]):
			friend = True
			keys = ["username", "firstname", "lastname", "email", "gender", "created_on", "avatar", "protected", "blocked"]
		else:
			keys = ["username", "firstname", "lastname", "gender", "created_on", "protected", "blocked"]

		details = {}

		for k in keys:
			details[k] = user[k]

		if friend:
			details["following"] = db.get_followed_usernames(scope, user["username"])

		return details

	# creates a database connection:
	def __create_db_connection__(self):
		return factory.create_db_connection()

	# creates a database.UserDb instance:
	def __create_user_db__(self):
		return factory.create_user_db()

	# throws an exception.UserNotFoundException if the given user account does not exist
	def __test_user_exists__(self, scope, db, username):
		if not db.user_exists(scope, username):
			raise exception.UserNotFoundException()

	# throws an exception.UserIsBlockedException when the given user account is blocked:
	def __test_active_user__(self, scope, db, username):
		self.__test_user_exists__(scope, db, username)

		if db.user_is_blocked(scope, username):
			raise exception.UserIsBlockedException()

	# validates a password:
	def __validate_password__(self, scope, db, username, password):
		current_password, salt = db.get_user_password(scope, username)

		return util.password_hash(password, salt) == current_password

"""
	## Gets object details.
	#  @param guid an object guid
	#  @return a dictionary holding object details ({ "guid": str, "source": str, "locked": bool,
	#          "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_object(self, guid):
		self.__test_object_exists__(guid)

		obj = self.__create_object_db__().get_object(guid)

		del obj["reported"]

		return obj

	## Gets objects from the data store.
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array, each element is a dictionary holding object details ({ "guid": str, "source": str,
	#          "locked": bool, "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_objects(self, page = 0, page_size = 10):
		return self.__create_object_db__().get_objects(page, page_size)

	## Gets objects assigned to a tag.
	#  @param tag tag to search
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array, each element is a dictionary holding object details ({ "guid": str, "source": str,
	#          "locked": bool, "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_tagged_objects(self, tag, page = 0, page_size = 10):
		return self.__create_object_db__().get_tagged_objects(tag, page, page_size)

	## Gets the most popular objects.
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array, each element is a dictionary holding object details ({ "guid": str, "source": str,
	#          "locked": bool, "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_popular_objects(self, page = 0, page_size = 10):
		return self.__create_object_db__().get_popular_objects(page, page_size)

	## Gets random objects.
	#  @param page_size number of objects the method should(!) return
	#  @return an array, each element is a dictionary holding object details ({ "guid": str, "source": str,
	#          "locked": bool, "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_random_objects(self, page_size = 10):
		return self.__create_object_db__().get_random_objects(page_size)

	## Adds tags to an object.
	#  @param username user who wants to add tags
	#  @param guid guid of an object
	#  @param tags array containing tags to add
	def add_tags(self, username, guid, tags):
		for tag in tags:
			if not validate_tag(tag):
				raise exception.InvalidParameterException("tag")

		self.__test_active_user__(username)
		self.__test_object_write_access__(guid)

		return self.__create_object_db__().add_tags(guid, tags)

	## Upvotes/Downvotes an object. Friends and unprotected followed receive a notification.
	#  @param username user who wants to vote
	#  @param guid guid of an object
	#  @param up True to upvote
	def rate(self, username, guid, up = True):
		self.__test_object_write_access__(guid)
		user = self.get_active_user(username)

		# rate:
		db = self.__create_object_db__()

		if not db.user_can_rate(guid, username):
			raise exception.UserAlreadyRatedException()

		db.rate(guid, username, up)

		# send messages:
		if len(user["following"]) > 0:
			streamdb = self.__create_stream_db__()
			map(lambda friend: streamdb.add_message(StreamDb.MessageType.VOTE, username, friend, guid = guid, up = up), self.__get_receivers__(user))

	## Adds an object to the favorites list of a user. Friends & unprotected followed users receive a notification.
	#  @param username user who wants to add the object to his/her favorites list
	#  @param guid guid of an object
	#  @param favor True to add the object to the list
	def favor(self, username, guid, favor = True):
		self.__test_object_exists__(guid)
		user = self.get_active_user(username)

		# create favorite:
		db = self.__create_object_db__()
		db.favor_object(guid, username, favor)

		# create messages:
		if favor and len(user["following"]) > 0:
			streamdb = self.__create_stream_db__()
			map(lambda friend: streamdb.add_message(StreamDb.MessageType.FAVOR, username, friend, guid = guid), self.__get_receivers__(user))

	## Returns the favorites list of a user.
	#  @param username a user account
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array, each element is a dictionary holding object details ({ "guid": str, "source": str,
	#          "locked": bool, "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_favorites(self, username, page = 0, page_size = 10):
		self.__test_active_user__(username)

		return self.__create_object_db__().get_favorites(username, page, page_size)

	## Appends a comment to an object. Friends & unprotected followed users receive a notification.
	#  @param guid guid of an object
	#  @param username author of the comment
	#  @param text text to append
	def add_comment(self, guid, username, text):
		if not validate_comment(text):
			raise exception.InvalidParameterException("comment")

		self.__test_object_write_access__(guid)
		user = self.get_active_user(username)

		# create comment:
		db = self.__create_object_db__()
		db.add_comment(guid, username, text)

		# send messages:
		if len(user["following"]) > 0:
			streamdb = self.__create_stream_db__()
			map(lambda friend:  streamdb.add_message(StreamDb.MessageType.COMMENT, username, friend, guid = guid, comment = text), self.__get_receivers__(user))

	## Gets comments assigned to an object.
	#  @param guid guid of an object
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array, each element is a dictionary holding a comment ({ "text": str, "timestamp": float,
	#          "user": { "name": str, "firstname": str, "lastname": str, "gender": str, "avatar": str, "blocked": bool })
	def get_comments(self, guid, page = 0, page_size = 10):
		self.__test_object_exists__(guid)

		return self.__create_object_db__().get_comments(guid, page, page_size)

	## Reports an object for abuse.
	#  @param guid guid of an object
	#  @return True if the object has been reported
	def report_abuse(self, guid):
		obj = self.__get_writeable_object__(guid)

		if not obj["reported"]:
			self.__create_object_db__().report(guid)

			return True

		return False

	## Lets a user recommend an object to his/her friends or followed unprotected users.
	#  Each receiver gets a notification.
	#  @param username user who wants to recommend an object
	#  @param guid guid of an object
	#  @param receivers array containing receiver names
	def recommend(self, username, guid, receivers):
		sender = self.get_active_user(username)
		self.__test_object_exists__(guid)

		# build valid receiver list:
		valid_receivers = []
		receivers_append = valid_receivers.append

		userdb = self.__create_user_db__()
		objdb = self.__create_object_db__()

		for r in receivers:
			if r != username and r in sender["following"]:
				try:
					user = self.get_active_user(r)

					if (not user["protected"] or username in user["following"]) and not objdb.recommendation_exists(guid, r):
						receivers_append(r)

				except exception.UserNotFoundException:
					pass

				except exception.UserIsBlockedException:
					pass

		# create recommendations:
		objdb.recommend(guid, username, valid_receivers)

		# send messages:
		streamdb = self.__create_stream_db__()
		map(lambda r: streamdb.add_message(StreamDb.MessageType.RECOMMENDATION, username, r, guid = guid), valid_receivers)

	## Gets objects recommended to a user.
	#  @param username a user account
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array, each element is a dictionary holding object details ({ "guid": str, "source": str,
	#          "locked": bool, "tags": [ str, str, ... ], "score": { "up": int, "down": int, "fav": int, "total": int },
	#          "timestamp": float, "comments_n": int })
	def get_recommendations(self, username, page = 0, page_size = 10):
		self.__test_active_user__(username)

		return self.__create_object_db__().get_recommendations(username, page, page_size)

	## Lets one user follow another user. The followed user receives a notification.
	#  @param user1 user who wants to follow another user
	#  @param user2 the user account user1 wants to follow
	#  @param follow True to follow, False to unfollow
	def follow(self, user1, user2, follow = True):
		if user1 == user2:
			raise InvalidParameterException("user2")

		self.__test_active_user__(user1)
		self.__test_active_user__(user2)

		# create/destroy friendship:
		self.__create_user_db__().follow(user1, user2, follow)

		# send messages:
		if follow:
			type_id = StreamDb.MessageType.FOLLOW
		else:
			type_id = StreamDb.MessageType.UNFOLLOW

		self.__create_stream_db__().add_message(type_id, user1, user2)

	## Tests if a user follows another user.
	#  @param user1 a user account
	#  @param user2 a user account
	#  @return True if user1 follows user2
	def is_following(self, user1, user2):
		return self.__create_user_db__().is_following(user1, user2)

	## Gets messages sent to a user account.
	#  @param username a user account
	#  @param limit number of messages to receive
	#  @param older_than filter to get only messages older than the specified timestamp
	#  @return an array, each element is a dictionary holding a message ({ "type_id": int, "timestamp": float,
	#          "sender": { "name": str, "firstname": str, "lastname": str, "gender": str, "avatar": str, "blocked": bool },
	#          [ optional fields depending on message type] })
	def get_messages(self, username, limit = 100, older_than = None):
		self.__test_active_user__(username)

		return self.__create_stream_db__().get_messages(username, limit, older_than)

	## Gets details of a user account. This methods also checks if the user is blocked or not.
	#  @param username a user account
	#  @return a dictionary holding user information ({ "name": str, "firstname": str, "lastname": str, "email": str,
	#          "gender": str, "timestamp": float, "avatar": str, "protected": bool, "following":  [ str, str, ... ],
	#          "language": str, "password": str, "blocked": bool })
	def get_active_user(self, username):
		db = self.__create_user_db__()

		user = db.get_user(username)

		if user is None:
			raise exception.UserNotFoundException()

		if user["blocked"]:
			raise exception.UserIsBlockedException()

		return user

	def __create_shared_client__(self):
		if self.__shared_client is None:
			self.__shared_client = factory.create_shared_client()

		return self.__shared_client

	def __create_object_db__(self):
		if self.__objectdb is None:
			self.__objectdb = factory.create_shared_object_db(self.__create_shared_client__())

		return self.__objectdb

	def __create_stream_db__(self):
		if self.__streamdb is None:
			self.__streamdb = factory.create_shared_stream_db(self.__create_shared_client__())

		return self.__streamdb

	def __test_active_user__(self, username):
		db = self.__create_user_db__()

		if not db.user_exists(username):
			raise exception.UserNotFoundException()

		if db.user_is_blocked(username):
			raise exception.UserIsBlockedException()

	def __test_object_exists__(self, guid):
		db = self.__create_object_db__()

		if not db.object_exists(guid):
			raise exception.ObjectNotFoundException()

	def __test_object_write_access__(self, guid):
		db = self.__create_object_db__()

		if not db.object_exists(guid):
			raise exception.ObjectNotFoundException()

		if db.is_locked(guid):
			raise exception.ObjectIsLockedException()

	def __get_writeable_object__(self, guid):
		obj = self.__create_object_db__().get_object(guid)

		if obj is None:
			raise exception.ObjectNotFoundException()

		if obj["locked"]:
			raise exception.ObjectIsLockedException()

		return obj

	def __get_receivers__(self, user):
		friends = []
		friends_append = friends.append

		for u in user["following"]:
			try:
				details = self.get_active_user(u)
				if not user["protected"] or user["name"] in details["following"]:
					friends_append(details["name"])

			except exception.UserIsBlockedException:
				pass

		return friends
"""

## This class holds the minimum data required for an authenticated request & the calculated checksum.
#
#  Each request has to provide the username of the authenticated user, an UNIX timestamp &
#  the checksum of all parameters (HMAC).
class RequestData:
	## The constructor.
	#  @param username name of the authenticated user
	#  @param timestamp timestamp of the request
	#  @param signature checksum of all parameters
	def __init__(self, username, timestamp = None, signature = None):
		## Username of the authenticated user.
		self.username = username
		## UNIX timstamp (UTC) of the request.
		self.timestamp = timestamp

		if timestamp is None:
			self.timestamp = util.unix_timestamp()

		## Checksum of all request parameters.
		self.signature = signature

## This class provides access to the data store for authenticated users.
#
#  The AuthenticatedApplication class provides nearly the same methods to access the
#  data store like the Application class. To get further information of a method please
#  have a look at the documentation of the Application class.
#
#  The main difference between both classes is that this one adds an authentication layer
#  to the application. Each request is validated by a checksum. To calculate this
#  checksum you have to order the parameters alphabetically. Then calculate the HMAC-SHA1
#  checksum using the hashed password (SHA-256) of the given user account. You find an
#  example algorithm in the utility module (util.sign_message).
class AuthenticatedApplication:
	def __init__(self):
		self.__app = None

	def __enter__(self):
		return self

	def __exit__(self, type, value, traceback):
		if not self.__app is None:
			del self.__app

	## Stores a user request in the data store.
	#  This method wraps Application::request_account().
	#  @param username name of the user to create
	#  @param email email address of the user
	#  @param user_request_timeout lifetime of the user request
	#  @return an auto-generated request code
	def request_account(self, username, email, user_request_timeout = config.USER_REQUEST_TIMEOUT):
		return self.__create_app__().request_account(username, email, user_request_timeout)

	## Generates a password request.
	#  This method wraps Application::request_password().
	#  @param username a user account
	#  @param email email address of the authenticated user account
	#  @return an auto-generated code
	def request_password(self, username, email):
		return self.__create_app__().request_password(username, email)

	## Generates a new password using a request code generated by the AuthenticatedApplication::request_password() method.
	#  This method wraps Application::generate_password().
	#  @param code a password request code
	#  @return username, email address & password (plaintext)
	def generate_password(self, code):
		return self.__create_app__().generate_password(code)

	## Activates a user account using an auto-generated request code.
	#  This method wraps Application::activate_user().
	#  @param code a request code generated by the AuthenticatedApplication::request_account() method
	#  @return username, email & password (plaintext)
	def activate_user(self, code):
		return self.__create_app__().activate_user(code)

	## Disables a user account.
	#  This method wraps Application::disable_user().
	#  @param req request data
	#  @param email email address of the authenticated user
	def disable_user(self, req, email):
		self.verify_message(req, email = email)

		app = self.__create_app__()
		user = app.get_active_user(req.username)

		if user["email"] != email:
			raise exception.InvalidEmailAddressException()

		app.disable_user(req.username)

	## Changes the password of a user account.
	#  This method wraps Application::change_password().
	#  @param req request data
	#  @param old_password old password (plaintext) of the authenticated account
	#  @param new_password a new password (plaintext) to set
	def change_password(self, req, old_password, new_password):
		self.verify_message(req, old_password = old_password, new_password = new_password)
		self.__create_app__().change_password(req.username, old_password, new_password)

	## Updates the details of a user account.
	#  This method wraps Application::update_user_details().
	#  @param req request data
	#  @param email email address to set
	#  @param firstname firstname to set
	#  @param lastname lastname to set
	#  @param gender gender to set
	#  @param language language to set
	#  @param protected protected status to set
	def update_user_details(self, req, email, firstname, lastname, gender, language, protected):
		self.verify_message(req, email = email, firstname = firstname, lastname = lastname, gender = gender, language = language, protected = protected)
		self.__create_app__().update_user_details(req.username, email, firstname, lastname, gender, language, protected)

	## Updates the avatar of a user account.
	#  This method wraps Application::update_avatar().
	#  @param req request data
	#  @param filename filename of the image
	#  @param stream input stream for reading image data
	def update_avatar(self, req, filename, stream):
		self.verify_message(req, filename = filename)
		self.__create_app__().update_avatar(req.username, filename, stream)

	## Finds users by search query.
	#  This method wraps Application::find_user().
	#  @param req request data
	#  @param query a search query
	#  @return an array
	def find_user(self, req, query):
		self.verify_message(req, query = query)

		return self.__create_app__().find_user(req.username, query)

	## Gets details of a user account depending on protected status & friendship.
	#  This method wraps Application::get_user_details().
	#  @param req request data
	#  @param name user to get details from
	#  @return a dictionary
	def get_user_details(self, req, name):
		self.verify_message(req, name = name)

		return self.__create_app__().get_user_details(req.username, name)

	## Gets object details.
	#  This method wraps Application::get_object().
	#  @param req request data
	#  @param guid guid of an object
	#  @return a dictionary
	def get_object(self, req, guid):
		self.verify_message(req, guid = guid)

		return self.__create_app__().get_object(guid)

	## Gets objects from the data store.
	#  This method wraps Application::get_objects().
	#  @param req request data
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array
	def get_objects(self, req, page, page_size):
		self.verify_message(req, page = page, page_size = page_size)

		return self.__create_app__().get_objects(page, page_size)

	## Gets objects assigned to a tag.
	#  This method wraps Application::get_tagged_objects().
	#  @param req request data
	#  @param tag tag to search
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array
	def get_tagged_objects(self, req, tag, page, page_size):
		self.verify_message(req, tag = tag, page = page, page_size = page_size)

		return self.__create_app__().get_tagged_objects(tag, page, page_size)

	## Gets the most popular objects.
	#  This method wraps Application::get_popular_objects().
	#  @param req request data
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array
	def get_popular_objects(self, req, page, page_size):
		self.verify_message(req, page = page, page_size = page_size)

		return self.__create_app__().get_popular_objects(page, page_size)

	## Gets random objects.
	#  This method wraps Application::get_random_objects().
	#  @param req request data
	#  @param page_size number of objects the method should(!) return
	#  @return an array
	def get_random_objects(self, req, page_size):
		self.verify_message(req, page_size = page_size)

		return self.__create_app__().get_random_objects(page_size)

	## Adds tags to an object.
	#  This method wraps Application::add_tags().
	#  @param req request data
	#  @param guid guid of an object
	#  @param tags array containing tags to add
	def add_tags(self, req, guid, tags):
		self.verify_message(req, guid = guid, tags = tags)
		self.__create_app__().add_tags(req.username, guid, tags)

	## Upvotes/Downvotes an object.
	#  This method wraps Application::rate().
	#  @param req request data
	#  @param guid guid of an object
	#  @param up True to upvote
	def rate(self, req, guid, up = True):
		self.verify_message(req, guid = guid, up = up)
		self.__create_app__().rate(req.username, guid, up)

	## Adds an object to the favorites list of a user.
	#  This method wraps Application::favor().
	#  @param req request data
	#  @param guid guid of an object
	#  @param favor True to add the object to the list
	def favor(self, req, guid, favor = True):
		self.verify_message(req, guid = guid, favor = favor)
		self.__create_app__().favor(req.username, guid, favor = favor)

	## Returns the favorites list of a user.
	#  This method wraps Application::get_favorites().
	#  @param req request data
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array
	def get_favorites(self, req, page, page_size):
		self.verify_message(req, page = page, page_size = page_size)

		return self.__create_app__().get_favorites(req.username, page, page_size)

	## Appends a comment to an object.
	#  This method wraps Application::add_comment().
	#  @param req request data
	#  @param guid guid of an object
	#  @param text text to append
	def add_comment(self, req, guid, text):
		self.verify_message(req, guid = guid, text = text)
		self.__create_app__().add_comment(guid, req.username, text)

	## Gets comments assigned to an object.
	#  This method wraps Application::get_comments().
	#  @param req request data
	#  @param guid guid of an object
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array
	def get_comments(self, req, guid, page, page_size):
		self.verify_message(req, guid = guid, page = page, page_size = page_size)

		return self.__create_app__().get_comments(guid, page, page_size)

	## Reports an object for abuse.
	#  This method wraps Application::report_abuse().
	#  @param req request data
	#  @param guid guid of an object
	#  @return True if the object has been reported
	def report_abuse(self, req, guid):
		self.verify_message(req, guid = guid)

		return self.__create_app__().report_abuse(guid)

	## Lets a user recommend an object to his/her friends.
	#  This method wraps Application::recommend().
	#  @param req request data
	#  @param guid guid of an object
	#  @param receivers array containing receiver names
	def recommend(self, req, guid, receivers):
		self.verify_message(req, guid = guid, receivers = receivers)
		self.__create_app__().recommend(req.username, guid, receivers)

	## Gets objects recommended to a user
	#  This method wraps Application::get_recommendations().
	#  @param req request data
	#  @param page page number
	#  @param page_size size of each page
	#  @return an array
	def get_recommendations(self, req, page, page_size):
		self.verify_message(req, page = page, page_size = page_size)

		return self.__create_app__().get_recommendations(req.username, page, page_size)

	## Lets one user follow another user.
	#  This method wraps Application::follow().
	#  @param req request data
	#  @param user a user account the authenticated user wants to follow
	#  @param follow True to follow, False to unfollow
	def follow(self, req, user, follow):
		self.verify_message(req, user = user, follow = follow)
		self.__create_app__().follow(req.username, user, follow)

	## Gets messages sent to a user account.
	#  This method wraps Application::get_messages().
	#  @param req request data
	#  @param limit number of messages to receive
	#  @param older_than filter to get only messages older than the specified timestamp
	#  @return an array
	def get_messages(self, req, limit, older_than):
		self.verify_message(req, limit = limit, older_than = older_than)

		return self.__create_app__().get_messages(req.username, limit, older_than)

	## Validates a signature.
	#  @param req request data
	#  @param kwargs additional arguments
	def verify_message(self, req, **kwargs):
		try:
			# validate timestamp:
			if util.unix_timestamp() - req.timestamp > config.REQUEST_EXPIRY_TIME:
				raise exception.RequestExpiredException

			# get user password:
			password = self.__get_user_password__(req.username)

			if password is None:
				raise exception.AuthenticationFailedException()

			# verify signature:
			kwargs["username"] = req.username
			kwargs["timestamp"] = req.timestamp

			signature = util.sign_message(str(password), **kwargs)

			if signature != req.signature:
				raise exception.AuthenticationFailedException()

		except exception.AuthenticationFailedException, ex:
			raise ex

		except exception.RequestExpiredException, ex:
			raise ex

		except Exception:
			raise exception.InvalidRequestException()

	## Gets the language of a user account.
	#  @param username name of a user account
	#  @return language of the user as string
	def get_user_language(self, username):
		user = self.__create_app__().get_full_user_details(username)

		if not user is None:
			if user["language"] is None:
				return config.DEFAULT_LANGUAGE

			return user["language"]

		raise exception.UserNotFoundException()

	def __get_user_password__(self, username):
		return self.__create_app__().get_password(username)

	def __create_app__(self):
		if self.__app is None:
			self.__app = Application()

		return self.__app
